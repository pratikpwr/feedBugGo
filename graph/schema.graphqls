#######################
# Input Schema
#######################

enum Flavor {
  dev
  qa
  prod
}

enum UserRole {
  admin
  user
}

enum TeamType {
  managment
  product
  design
  frontend
  mobile
  backend
  cs
  finance
  testing
  lowcode
}

enum TicketType {
  bug
  improvement
}

enum TicketPriority {
  highest
  high
  medium
  low
  lowest
}

enum TicketStatus {
  created
  willDo
  notDoing
  inProgress
  nextTime
  done
}

type User {
  id: ID!
  username: String!
  phone: String
  roles: [UserRole]
  password: String!
  skills: String
  experience: Float
  position: String
  team_type: [TeamType]!
}

type Project {
  id: ID!
  title: String!
  description: String
  image_url: String
  flavors: [Flavor]
  teams: [TeamType]
  tickets(filter: TicketFilter, order: TicketOrder, first: Int, offset: Int): [Ticket]
  ticketsAggregate(filter: TicketFilter): TicketAggregateResult
}

type Ticket {
  id: ID!
  title: String!
  project: String!
  description: String
  improvement: String
  ticket_type: TicketType
  flavor: Flavor
  priority: TicketPriority
  status: TicketStatus!
  occurrence_module: String
  occurrence_element: String
  device: String
  device_model: String
  created_by: String!
  assigned_to: String
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
}

type Comment {
  comment: String!
  comment_by(filter: UserFilter): User!
  ticket(filter: TicketFilter): Ticket!
  created_at: DateTime
}

#######################
# Extended Definitions
#######################

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input IntRange{
  min: Int!
  max: Int!
}

input FloatRange{
  min: Float!
  max: Float!
}

input Int64Range{
  min: Int64!
  max: Int64!
}

input DateTimeRange{
  min: DateTime!
  max: DateTime!
}

input StringRange{
  min: String!
  max: String!
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

enum Mode {
  BATCH
  SINGLE
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

input WithinFilter {
  polygon: PolygonRef!
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

directive @hasInverse(field: String!) on FIELD_DEFINITION
directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION
directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION
directive @id on FIELD_DEFINITION
directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION
directive @secret(field: String!, pred: String) on OBJECT | INTERFACE
directive @auth(
  password: AuthRule
  query: AuthRule,
  add: AuthRule,
  update: AuthRule,
  delete: AuthRule) on OBJECT | INTERFACE
directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION
directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM
directive @remoteResponse(name: String) on FIELD_DEFINITION
directive @cascade(fields: [String]) on FIELD
directive @lambda on FIELD_DEFINITION
directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT | INTERFACE
directive @cacheControl(maxAge: Int!) on QUERY
directive @generate(
  query: GenerateQueryParams,
  mutation: GenerateMutationParams,
  subscription: Boolean) on OBJECT | INTERFACE

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input StringRegExpFilter {
  regexp: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringHashFilter {
  eq: String
  in: [String]
}

#######################
# Generated Types
#######################

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

type AddTicketPayload {
  ticket(filter: TicketFilter, order: TicketOrder, first: Int, offset: Int): [Ticket]
  numUids: Int
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type CommentAggregateResult {
  count: Int
  commentMin: String
  commentMax: String
  created_atMin: DateTime
  created_atMax: DateTime
}

type DeleteCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  msg: String
  numUids: Int
}

type DeleteProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  msg: String
  numUids: Int
}

type DeleteTicketPayload {
  ticket(filter: TicketFilter, order: TicketOrder, first: Int, offset: Int): [Ticket]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type ProjectAggregateResult {
  count: Int
  titleMin: String
  titleMax: String
  descriptionMin: String
  descriptionMax: String
  image_urlMin: String
  image_urlMax: String
}

type TicketAggregateResult {
  count: Int
  titleMin: String
  titleMax: String
  projectMin: String
  projectMax: String
  descriptionMin: String
  descriptionMax: String
  improvementMin: String
  improvementMax: String
  occurrence_moduleMin: String
  occurrence_moduleMax: String
  occurrence_elementMin: String
  occurrence_elementMax: String
  deviceMin: String
  deviceMax: String
  device_modelMin: String
  device_modelMax: String
  created_byMin: String
  created_byMax: String
  assigned_toMin: String
  assigned_toMax: String
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

type UpdateTicketPayload {
  ticket(filter: TicketFilter, order: TicketOrder, first: Int, offset: Int): [Ticket]
  numUids: Int
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type UserAggregateResult {
  count: Int
  usernameMin: String
  usernameMax: String
  phoneMin: String
  phoneMax: String
  passwordMin: String
  passwordMax: String
  skillsMin: String
  skillsMax: String
  experienceMin: Float
  experienceMax: Float
  experienceSum: Float
  experienceAvg: Float
  positionMin: String
  positionMax: String
}

#######################
# Generated Enums
#######################

enum CommentHasFilter {
  comment
  comment_by
  ticket
  created_at
}

enum CommentOrderable {
  comment
  created_at
}

enum ProjectHasFilter {
  title
  description
  image_url
  flavors
  teams
  tickets
}

enum ProjectOrderable {
  title
  description
  image_url
}

enum TicketHasFilter {
  title
  project
  description
  improvement
  ticket_type
  flavor
  priority
  status
  occurrence_module
  occurrence_element
  device
  device_model
  created_by
  assigned_to
  comments
}

enum TicketOrderable {
  title
  project
  description
  improvement
  occurrence_module
  occurrence_element
  device
  device_model
  created_by
  assigned_to
}

enum UserHasFilter {
  username
  phone
  roles
  password
  skills
  experience
  position
  team_type
}

enum UserOrderable {
  username
  phone
  password
  skills
  experience
  position
}

#######################
# Generated Inputs
#######################

input AddCommentInput {
  comment: String!
  comment_by: UserRef!
  ticket: TicketRef!
  created_at: DateTime
}

input AddProjectInput {
  title: String!
  description: String
  image_url: String
  flavors: [Flavor]
  teams: [TeamType]
  tickets: [TicketRef]
}

input AddTicketInput {
  title: String!
  project: String!
  description: String
  improvement: String
  ticket_type: TicketType
  flavor: Flavor
  priority: TicketPriority
  status: TicketStatus!
  occurrence_module: String
  occurrence_element: String
  device: String
  device_model: String
  created_by: String!
  assigned_to: String
  comments: [CommentRef]
}

input AddUserInput {
  username: String!
  phone: String
  roles: [UserRole]
  password: String!
  skills: String
  experience: Float
  position: String
  team_type: [TeamType]!
}

input CommentFilter {
  has: [CommentHasFilter]
  and: [CommentFilter]
  or: [CommentFilter]
  not: CommentFilter
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

input CommentPatch {
  comment: String
  comment_by: UserRef
  ticket: TicketRef
  created_at: DateTime
}

input CommentRef {
  comment: String
  comment_by: UserRef
  ticket: TicketRef
  created_at: DateTime
}

input ProjectFilter {
  id: [ID!]
  has: [ProjectHasFilter]
  and: [ProjectFilter]
  or: [ProjectFilter]
  not: ProjectFilter
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

input ProjectPatch {
  title: String
  description: String
  image_url: String
  flavors: [Flavor]
  teams: [TeamType]
  tickets: [TicketRef]
}

input ProjectRef {
  id: ID
  title: String
  description: String
  image_url: String
  flavors: [Flavor]
  teams: [TeamType]
  tickets: [TicketRef]
}

input TicketFilter {
  id: [ID!]
  has: [TicketHasFilter]
  and: [TicketFilter]
  or: [TicketFilter]
  not: TicketFilter
}

input TicketOrder {
  asc: TicketOrderable
  desc: TicketOrderable
  then: TicketOrder
}

input TicketPatch {
  title: String
  project: String
  description: String
  improvement: String
  ticket_type: TicketType
  flavor: Flavor
  priority: TicketPriority
  status: TicketStatus
  occurrence_module: String
  occurrence_element: String
  device: String
  device_model: String
  created_by: String
  assigned_to: String
  comments: [CommentRef]
}

input TicketRef {
  id: ID
  title: String
  project: String
  description: String
  improvement: String
  ticket_type: TicketType
  flavor: Flavor
  priority: TicketPriority
  status: TicketStatus
  occurrence_module: String
  occurrence_element: String
  device: String
  device_model: String
  created_by: String
  assigned_to: String
  comments: [CommentRef]
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

input UpdateTicketInput {
  filter: TicketFilter!
  set: TicketPatch
  remove: TicketPatch
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

input UserFilter {
  id: [ID!]
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

input UserPatch {
  username: String
  phone: String
  roles: [UserRole]
  password: String
  skills: String
  experience: Float
  position: String
  team_type: [TeamType]
}

input UserRef {
  id: ID
  username: String
  phone: String
  roles: [UserRole]
  password: String
  skills: String
  experience: Float
  position: String
  team_type: [TeamType]
}

#######################
# Generated Query
#######################

type Query {
  getUser(id: ID!): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  aggregateProject(filter: ProjectFilter): ProjectAggregateResult
  getTicket(id: ID!): Ticket
  queryTicket(filter: TicketFilter, order: TicketOrder, first: Int, offset: Int): [Ticket]
  aggregateTicket(filter: TicketFilter): TicketAggregateResult
  queryComment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  aggregateComment(filter: CommentFilter): CommentAggregateResult
}

#######################
# Generated Mutations
#######################

type Mutation {
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addProject(input: [AddProjectInput!]!): AddProjectPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  deleteProject(filter: ProjectFilter!): DeleteProjectPayload
  addTicket(input: [AddTicketInput!]!): AddTicketPayload
  updateTicket(input: UpdateTicketInput!): UpdateTicketPayload
  deleteTicket(filter: TicketFilter!): DeleteTicketPayload
  addComment(input: [AddCommentInput!]!): AddCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  deleteComment(filter: CommentFilter!): DeleteCommentPayload
}

