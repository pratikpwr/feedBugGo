// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddCommentInput struct {
	Comment   string     `json:"comment"`
	CommentBy *UserRef   `json:"comment_by"`
	Ticket    *TicketRef `json:"ticket"`
	CreatedAt *string    `json:"created_at"`
}

type AddCommentPayload struct {
	Comment []*Comment `json:"comment"`
	NumUids *int       `json:"numUids"`
}

type AddProjectInput struct {
	Title       string       `json:"title"`
	Description *string      `json:"description"`
	ImageURL    *string      `json:"image_url"`
	Flavors     []*Flavor    `json:"flavors"`
	Teams       []*TeamType  `json:"teams"`
	Tickets     []*TicketRef `json:"tickets"`
}

type AddProjectPayload struct {
	Project []*Project `json:"project"`
	NumUids *int       `json:"numUids"`
}

type AddTicketInput struct {
	Title             string          `json:"title"`
	Project           string          `json:"project"`
	Description       *string         `json:"description"`
	Improvement       *string         `json:"improvement"`
	TicketType        *TicketType     `json:"ticket_type"`
	Flavor            *Flavor         `json:"flavor"`
	Priority          *TicketPriority `json:"priority"`
	Status            TicketStatus    `json:"status"`
	OccurrenceModule  *string         `json:"occurrence_module"`
	OccurrenceElement *string         `json:"occurrence_element"`
	Device            *string         `json:"device"`
	DeviceModel       *string         `json:"device_model"`
	CreatedBy         string          `json:"created_by"`
	AssignedTo        *string         `json:"assigned_to"`
	Comments          []*CommentRef   `json:"comments"`
}

type AddTicketPayload struct {
	Ticket  []*Ticket `json:"ticket"`
	NumUids *int      `json:"numUids"`
}

type AddUserInput struct {
	Username   string      `json:"username"`
	Phone      *string     `json:"phone"`
	Roles      []*UserRole `json:"roles"`
	Password   string      `json:"password"`
	Skills     *string     `json:"skills"`
	Experience *float64    `json:"experience"`
	Position   *string     `json:"position"`
	TeamType   []*TeamType `json:"team_type"`
}

type AddUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int    `json:"numUids"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and"`
	Or   []*AuthRule `json:"or"`
	Not  *AuthRule   `json:"not"`
	Rule *string     `json:"rule"`
}

type Comment struct {
	Comment   string  `json:"comment"`
	CommentBy *User   `json:"comment_by"`
	Ticket    *Ticket `json:"ticket"`
	CreatedAt *string `json:"created_at"`
}

type CommentAggregateResult struct {
	Count        *int    `json:"count"`
	CommentMin   *string `json:"commentMin"`
	CommentMax   *string `json:"commentMax"`
	CreatedAtMin *string `json:"created_atMin"`
	CreatedAtMax *string `json:"created_atMax"`
}

type CommentFilter struct {
	Has []*CommentHasFilter `json:"has"`
	And []*CommentFilter    `json:"and"`
	Or  []*CommentFilter    `json:"or"`
	Not *CommentFilter      `json:"not"`
}

type CommentOrder struct {
	Asc  *CommentOrderable `json:"asc"`
	Desc *CommentOrderable `json:"desc"`
	Then *CommentOrder     `json:"then"`
}

type CommentPatch struct {
	Comment   *string    `json:"comment"`
	CommentBy *UserRef   `json:"comment_by"`
	Ticket    *TicketRef `json:"ticket"`
	CreatedAt *string    `json:"created_at"`
}

type CommentRef struct {
	Comment   *string    `json:"comment"`
	CommentBy *UserRef   `json:"comment_by"`
	Ticket    *TicketRef `json:"ticket"`
	CreatedAt *string    `json:"created_at"`
}

type ContainsFilter struct {
	Point   *PointRef   `json:"point"`
	Polygon *PolygonRef `json:"polygon"`
}

type CustomHTTP struct {
	URL                  string     `json:"url"`
	Method               HTTPMethod `json:"method"`
	Body                 *string    `json:"body"`
	Graphql              *string    `json:"graphql"`
	Mode                 *Mode      `json:"mode"`
	ForwardHeaders       []string   `json:"forwardHeaders"`
	SecretHeaders        []string   `json:"secretHeaders"`
	IntrospectionHeaders []string   `json:"introspectionHeaders"`
	SkipIntrospection    *bool      `json:"skipIntrospection"`
}

type DateTimeFilter struct {
	Eq      *string        `json:"eq"`
	In      []*string      `json:"in"`
	Le      *string        `json:"le"`
	Lt      *string        `json:"lt"`
	Ge      *string        `json:"ge"`
	Gt      *string        `json:"gt"`
	Between *DateTimeRange `json:"between"`
}

type DateTimeRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type DeleteCommentPayload struct {
	Comment []*Comment `json:"comment"`
	Msg     *string    `json:"msg"`
	NumUids *int       `json:"numUids"`
}

type DeleteProjectPayload struct {
	Project []*Project `json:"project"`
	Msg     *string    `json:"msg"`
	NumUids *int       `json:"numUids"`
}

type DeleteTicketPayload struct {
	Ticket  []*Ticket `json:"ticket"`
	Msg     *string   `json:"msg"`
	NumUids *int      `json:"numUids"`
}

type DeleteUserPayload struct {
	User    []*User `json:"user"`
	Msg     *string `json:"msg"`
	NumUids *int    `json:"numUids"`
}

type FloatFilter struct {
	Eq      *float64    `json:"eq"`
	In      []*float64  `json:"in"`
	Le      *float64    `json:"le"`
	Lt      *float64    `json:"lt"`
	Ge      *float64    `json:"ge"`
	Gt      *float64    `json:"gt"`
	Between *FloatRange `json:"between"`
}

type FloatRange struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type GenerateMutationParams struct {
	Add    *bool `json:"add"`
	Update *bool `json:"update"`
	Delete *bool `json:"delete"`
}

type GenerateQueryParams struct {
	Get       *bool `json:"get"`
	Query     *bool `json:"query"`
	Password  *bool `json:"password"`
	Aggregate *bool `json:"aggregate"`
}

type Int64Filter struct {
	Eq      *string     `json:"eq"`
	In      []*string   `json:"in"`
	Le      *string     `json:"le"`
	Lt      *string     `json:"lt"`
	Ge      *string     `json:"ge"`
	Gt      *string     `json:"gt"`
	Between *Int64Range `json:"between"`
}

type Int64Range struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type IntFilter struct {
	Eq      *int      `json:"eq"`
	In      []*int    `json:"in"`
	Le      *int      `json:"le"`
	Lt      *int      `json:"lt"`
	Ge      *int      `json:"ge"`
	Gt      *int      `json:"gt"`
	Between *IntRange `json:"between"`
}

type IntRange struct {
	Min int `json:"min"`
	Max int `json:"max"`
}

type IntersectsFilter struct {
	Polygon      *PolygonRef      `json:"polygon"`
	MultiPolygon *MultiPolygonRef `json:"multiPolygon"`
}

type MultiPolygon struct {
	Polygons []*Polygon `json:"polygons"`
}

type MultiPolygonRef struct {
	Polygons []*PolygonRef `json:"polygons"`
}

type NearFilter struct {
	Distance   float64   `json:"distance"`
	Coordinate *PointRef `json:"coordinate"`
}

type Point struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PointGeoFilter struct {
	Near   *NearFilter   `json:"near"`
	Within *WithinFilter `json:"within"`
}

type PointList struct {
	Points []*Point `json:"points"`
}

type PointListRef struct {
	Points []*PointRef `json:"points"`
}

type PointRef struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type Polygon struct {
	Coordinates []*PointList `json:"coordinates"`
}

type PolygonGeoFilter struct {
	Near       *NearFilter       `json:"near"`
	Within     *WithinFilter     `json:"within"`
	Contains   *ContainsFilter   `json:"contains"`
	Intersects *IntersectsFilter `json:"intersects"`
}

type PolygonRef struct {
	Coordinates []*PointListRef `json:"coordinates"`
}

type Project struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      *string                `json:"description"`
	ImageURL         *string                `json:"image_url"`
	Flavors          []*Flavor              `json:"flavors"`
	Teams            []*TeamType            `json:"teams"`
	Tickets          []*Ticket              `json:"tickets"`
	TicketsAggregate *TicketAggregateResult `json:"ticketsAggregate"`
}

type ProjectAggregateResult struct {
	Count          *int    `json:"count"`
	TitleMin       *string `json:"titleMin"`
	TitleMax       *string `json:"titleMax"`
	DescriptionMin *string `json:"descriptionMin"`
	DescriptionMax *string `json:"descriptionMax"`
	ImageURLMin    *string `json:"image_urlMin"`
	ImageURLMax    *string `json:"image_urlMax"`
}

type ProjectFilter struct {
	ID  []string            `json:"id"`
	Has []*ProjectHasFilter `json:"has"`
	And []*ProjectFilter    `json:"and"`
	Or  []*ProjectFilter    `json:"or"`
	Not *ProjectFilter      `json:"not"`
}

type ProjectOrder struct {
	Asc  *ProjectOrderable `json:"asc"`
	Desc *ProjectOrderable `json:"desc"`
	Then *ProjectOrder     `json:"then"`
}

type ProjectPatch struct {
	Title       *string      `json:"title"`
	Description *string      `json:"description"`
	ImageURL    *string      `json:"image_url"`
	Flavors     []*Flavor    `json:"flavors"`
	Teams       []*TeamType  `json:"teams"`
	Tickets     []*TicketRef `json:"tickets"`
}

type ProjectRef struct {
	ID          *string      `json:"id"`
	Title       *string      `json:"title"`
	Description *string      `json:"description"`
	ImageURL    *string      `json:"image_url"`
	Flavors     []*Flavor    `json:"flavors"`
	Teams       []*TeamType  `json:"teams"`
	Tickets     []*TicketRef `json:"tickets"`
}

type StringExactFilter struct {
	Eq      *string      `json:"eq"`
	In      []*string    `json:"in"`
	Le      *string      `json:"le"`
	Lt      *string      `json:"lt"`
	Ge      *string      `json:"ge"`
	Gt      *string      `json:"gt"`
	Between *StringRange `json:"between"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext"`
	Anyoftext *string `json:"anyoftext"`
}

type StringHashFilter struct {
	Eq *string   `json:"eq"`
	In []*string `json:"in"`
}

type StringRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms"`
	Anyofterms *string `json:"anyofterms"`
}

type Ticket struct {
	ID                string                  `json:"id"`
	Title             string                  `json:"title"`
	Project           string                  `json:"project"`
	Description       *string                 `json:"description"`
	Improvement       *string                 `json:"improvement"`
	TicketType        *TicketType             `json:"ticket_type"`
	Flavor            *Flavor                 `json:"flavor"`
	Priority          *TicketPriority         `json:"priority"`
	Status            TicketStatus            `json:"status"`
	OccurrenceModule  *string                 `json:"occurrence_module"`
	OccurrenceElement *string                 `json:"occurrence_element"`
	Device            *string                 `json:"device"`
	DeviceModel       *string                 `json:"device_model"`
	CreatedBy         string                  `json:"created_by"`
	AssignedTo        *string                 `json:"assigned_to"`
	Comments          []*Comment              `json:"comments"`
	CommentsAggregate *CommentAggregateResult `json:"commentsAggregate"`
}

type TicketAggregateResult struct {
	Count                *int    `json:"count"`
	TitleMin             *string `json:"titleMin"`
	TitleMax             *string `json:"titleMax"`
	ProjectMin           *string `json:"projectMin"`
	ProjectMax           *string `json:"projectMax"`
	DescriptionMin       *string `json:"descriptionMin"`
	DescriptionMax       *string `json:"descriptionMax"`
	ImprovementMin       *string `json:"improvementMin"`
	ImprovementMax       *string `json:"improvementMax"`
	OccurrenceModuleMin  *string `json:"occurrence_moduleMin"`
	OccurrenceModuleMax  *string `json:"occurrence_moduleMax"`
	OccurrenceElementMin *string `json:"occurrence_elementMin"`
	OccurrenceElementMax *string `json:"occurrence_elementMax"`
	DeviceMin            *string `json:"deviceMin"`
	DeviceMax            *string `json:"deviceMax"`
	DeviceModelMin       *string `json:"device_modelMin"`
	DeviceModelMax       *string `json:"device_modelMax"`
	CreatedByMin         *string `json:"created_byMin"`
	CreatedByMax         *string `json:"created_byMax"`
	AssignedToMin        *string `json:"assigned_toMin"`
	AssignedToMax        *string `json:"assigned_toMax"`
}

type TicketFilter struct {
	ID  []string           `json:"id"`
	Has []*TicketHasFilter `json:"has"`
	And []*TicketFilter    `json:"and"`
	Or  []*TicketFilter    `json:"or"`
	Not *TicketFilter      `json:"not"`
}

type TicketOrder struct {
	Asc  *TicketOrderable `json:"asc"`
	Desc *TicketOrderable `json:"desc"`
	Then *TicketOrder     `json:"then"`
}

type TicketPatch struct {
	Title             *string         `json:"title"`
	Project           *string         `json:"project"`
	Description       *string         `json:"description"`
	Improvement       *string         `json:"improvement"`
	TicketType        *TicketType     `json:"ticket_type"`
	Flavor            *Flavor         `json:"flavor"`
	Priority          *TicketPriority `json:"priority"`
	Status            *TicketStatus   `json:"status"`
	OccurrenceModule  *string         `json:"occurrence_module"`
	OccurrenceElement *string         `json:"occurrence_element"`
	Device            *string         `json:"device"`
	DeviceModel       *string         `json:"device_model"`
	CreatedBy         *string         `json:"created_by"`
	AssignedTo        *string         `json:"assigned_to"`
	Comments          []*CommentRef   `json:"comments"`
}

type TicketRef struct {
	ID                *string         `json:"id"`
	Title             *string         `json:"title"`
	Project           *string         `json:"project"`
	Description       *string         `json:"description"`
	Improvement       *string         `json:"improvement"`
	TicketType        *TicketType     `json:"ticket_type"`
	Flavor            *Flavor         `json:"flavor"`
	Priority          *TicketPriority `json:"priority"`
	Status            *TicketStatus   `json:"status"`
	OccurrenceModule  *string         `json:"occurrence_module"`
	OccurrenceElement *string         `json:"occurrence_element"`
	Device            *string         `json:"device"`
	DeviceModel       *string         `json:"device_model"`
	CreatedBy         *string         `json:"created_by"`
	AssignedTo        *string         `json:"assigned_to"`
	Comments          []*CommentRef   `json:"comments"`
}

type UpdateCommentInput struct {
	Filter *CommentFilter `json:"filter"`
	Set    *CommentPatch  `json:"set"`
	Remove *CommentPatch  `json:"remove"`
}

type UpdateCommentPayload struct {
	Comment []*Comment `json:"comment"`
	NumUids *int       `json:"numUids"`
}

type UpdateProjectInput struct {
	Filter *ProjectFilter `json:"filter"`
	Set    *ProjectPatch  `json:"set"`
	Remove *ProjectPatch  `json:"remove"`
}

type UpdateProjectPayload struct {
	Project []*Project `json:"project"`
	NumUids *int       `json:"numUids"`
}

type UpdateTicketInput struct {
	Filter *TicketFilter `json:"filter"`
	Set    *TicketPatch  `json:"set"`
	Remove *TicketPatch  `json:"remove"`
}

type UpdateTicketPayload struct {
	Ticket  []*Ticket `json:"ticket"`
	NumUids *int      `json:"numUids"`
}

type UpdateUserInput struct {
	Filter *UserFilter `json:"filter"`
	Set    *UserPatch  `json:"set"`
	Remove *UserPatch  `json:"remove"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int    `json:"numUids"`
}

type User struct {
	ID         string      `json:"id"`
	Username   string      `json:"username"`
	Phone      *string     `json:"phone"`
	Roles      []*UserRole `json:"roles"`
	Password   string      `json:"password"`
	Skills     *string     `json:"skills"`
	Experience *float64    `json:"experience"`
	Position   *string     `json:"position"`
	TeamType   []*TeamType `json:"team_type"`
}

type UserAggregateResult struct {
	Count         *int     `json:"count"`
	UsernameMin   *string  `json:"usernameMin"`
	UsernameMax   *string  `json:"usernameMax"`
	PhoneMin      *string  `json:"phoneMin"`
	PhoneMax      *string  `json:"phoneMax"`
	PasswordMin   *string  `json:"passwordMin"`
	PasswordMax   *string  `json:"passwordMax"`
	SkillsMin     *string  `json:"skillsMin"`
	SkillsMax     *string  `json:"skillsMax"`
	ExperienceMin *float64 `json:"experienceMin"`
	ExperienceMax *float64 `json:"experienceMax"`
	ExperienceSum *float64 `json:"experienceSum"`
	ExperienceAvg *float64 `json:"experienceAvg"`
	PositionMin   *string  `json:"positionMin"`
	PositionMax   *string  `json:"positionMax"`
}

type UserFilter struct {
	ID  []string         `json:"id"`
	Has []*UserHasFilter `json:"has"`
	And []*UserFilter    `json:"and"`
	Or  []*UserFilter    `json:"or"`
	Not *UserFilter      `json:"not"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc"`
	Desc *UserOrderable `json:"desc"`
	Then *UserOrder     `json:"then"`
}

type UserPatch struct {
	Username   *string     `json:"username"`
	Phone      *string     `json:"phone"`
	Roles      []*UserRole `json:"roles"`
	Password   *string     `json:"password"`
	Skills     *string     `json:"skills"`
	Experience *float64    `json:"experience"`
	Position   *string     `json:"position"`
	TeamType   []*TeamType `json:"team_type"`
}

type UserRef struct {
	ID         *string     `json:"id"`
	Username   *string     `json:"username"`
	Phone      *string     `json:"phone"`
	Roles      []*UserRole `json:"roles"`
	Password   *string     `json:"password"`
	Skills     *string     `json:"skills"`
	Experience *float64    `json:"experience"`
	Position   *string     `json:"position"`
	TeamType   []*TeamType `json:"team_type"`
}

type WithinFilter struct {
	Polygon *PolygonRef `json:"polygon"`
}

type CommentHasFilter string

const (
	CommentHasFilterComment   CommentHasFilter = "comment"
	CommentHasFilterCommentBy CommentHasFilter = "comment_by"
	CommentHasFilterTicket    CommentHasFilter = "ticket"
	CommentHasFilterCreatedAt CommentHasFilter = "created_at"
)

var AllCommentHasFilter = []CommentHasFilter{
	CommentHasFilterComment,
	CommentHasFilterCommentBy,
	CommentHasFilterTicket,
	CommentHasFilterCreatedAt,
}

func (e CommentHasFilter) IsValid() bool {
	switch e {
	case CommentHasFilterComment, CommentHasFilterCommentBy, CommentHasFilterTicket, CommentHasFilterCreatedAt:
		return true
	}
	return false
}

func (e CommentHasFilter) String() string {
	return string(e)
}

func (e *CommentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentHasFilter", str)
	}
	return nil
}

func (e CommentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentOrderable string

const (
	CommentOrderableComment   CommentOrderable = "comment"
	CommentOrderableCreatedAt CommentOrderable = "created_at"
)

var AllCommentOrderable = []CommentOrderable{
	CommentOrderableComment,
	CommentOrderableCreatedAt,
}

func (e CommentOrderable) IsValid() bool {
	switch e {
	case CommentOrderableComment, CommentOrderableCreatedAt:
		return true
	}
	return false
}

func (e CommentOrderable) String() string {
	return string(e)
}

func (e *CommentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderable", str)
	}
	return nil
}

func (e CommentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexInt64    DgraphIndex = "int64"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
	DgraphIndexGeo      DgraphIndex = "geo"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexInt64,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
	DgraphIndexGeo,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexInt64, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour, DgraphIndexGeo:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Flavor string

const (
	FlavorDev  Flavor = "dev"
	FlavorQa   Flavor = "qa"
	FlavorProd Flavor = "prod"
)

var AllFlavor = []Flavor{
	FlavorDev,
	FlavorQa,
	FlavorProd,
}

func (e Flavor) IsValid() bool {
	switch e {
	case FlavorDev, FlavorQa, FlavorProd:
		return true
	}
	return false
}

func (e Flavor) String() string {
	return string(e)
}

func (e *Flavor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Flavor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Flavor", str)
	}
	return nil
}

func (e Flavor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectHasFilter string

const (
	ProjectHasFilterTitle       ProjectHasFilter = "title"
	ProjectHasFilterDescription ProjectHasFilter = "description"
	ProjectHasFilterImageURL    ProjectHasFilter = "image_url"
	ProjectHasFilterFlavors     ProjectHasFilter = "flavors"
	ProjectHasFilterTeams       ProjectHasFilter = "teams"
	ProjectHasFilterTickets     ProjectHasFilter = "tickets"
)

var AllProjectHasFilter = []ProjectHasFilter{
	ProjectHasFilterTitle,
	ProjectHasFilterDescription,
	ProjectHasFilterImageURL,
	ProjectHasFilterFlavors,
	ProjectHasFilterTeams,
	ProjectHasFilterTickets,
}

func (e ProjectHasFilter) IsValid() bool {
	switch e {
	case ProjectHasFilterTitle, ProjectHasFilterDescription, ProjectHasFilterImageURL, ProjectHasFilterFlavors, ProjectHasFilterTeams, ProjectHasFilterTickets:
		return true
	}
	return false
}

func (e ProjectHasFilter) String() string {
	return string(e)
}

func (e *ProjectHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectHasFilter", str)
	}
	return nil
}

func (e ProjectHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectOrderable string

const (
	ProjectOrderableTitle       ProjectOrderable = "title"
	ProjectOrderableDescription ProjectOrderable = "description"
	ProjectOrderableImageURL    ProjectOrderable = "image_url"
)

var AllProjectOrderable = []ProjectOrderable{
	ProjectOrderableTitle,
	ProjectOrderableDescription,
	ProjectOrderableImageURL,
}

func (e ProjectOrderable) IsValid() bool {
	switch e {
	case ProjectOrderableTitle, ProjectOrderableDescription, ProjectOrderableImageURL:
		return true
	}
	return false
}

func (e ProjectOrderable) String() string {
	return string(e)
}

func (e *ProjectOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectOrderable", str)
	}
	return nil
}

func (e ProjectOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TeamType string

const (
	TeamTypeManagment TeamType = "managment"
	TeamTypeProduct   TeamType = "product"
	TeamTypeDesign    TeamType = "design"
	TeamTypeFrontend  TeamType = "frontend"
	TeamTypeMobile    TeamType = "mobile"
	TeamTypeBackend   TeamType = "backend"
	TeamTypeCs        TeamType = "cs"
	TeamTypeFinance   TeamType = "finance"
	TeamTypeTesting   TeamType = "testing"
	TeamTypeLowcode   TeamType = "lowcode"
)

var AllTeamType = []TeamType{
	TeamTypeManagment,
	TeamTypeProduct,
	TeamTypeDesign,
	TeamTypeFrontend,
	TeamTypeMobile,
	TeamTypeBackend,
	TeamTypeCs,
	TeamTypeFinance,
	TeamTypeTesting,
	TeamTypeLowcode,
}

func (e TeamType) IsValid() bool {
	switch e {
	case TeamTypeManagment, TeamTypeProduct, TeamTypeDesign, TeamTypeFrontend, TeamTypeMobile, TeamTypeBackend, TeamTypeCs, TeamTypeFinance, TeamTypeTesting, TeamTypeLowcode:
		return true
	}
	return false
}

func (e TeamType) String() string {
	return string(e)
}

func (e *TeamType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamType", str)
	}
	return nil
}

func (e TeamType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TicketHasFilter string

const (
	TicketHasFilterTitle             TicketHasFilter = "title"
	TicketHasFilterProject           TicketHasFilter = "project"
	TicketHasFilterDescription       TicketHasFilter = "description"
	TicketHasFilterImprovement       TicketHasFilter = "improvement"
	TicketHasFilterTicketType        TicketHasFilter = "ticket_type"
	TicketHasFilterFlavor            TicketHasFilter = "flavor"
	TicketHasFilterPriority          TicketHasFilter = "priority"
	TicketHasFilterStatus            TicketHasFilter = "status"
	TicketHasFilterOccurrenceModule  TicketHasFilter = "occurrence_module"
	TicketHasFilterOccurrenceElement TicketHasFilter = "occurrence_element"
	TicketHasFilterDevice            TicketHasFilter = "device"
	TicketHasFilterDeviceModel       TicketHasFilter = "device_model"
	TicketHasFilterCreatedBy         TicketHasFilter = "created_by"
	TicketHasFilterAssignedTo        TicketHasFilter = "assigned_to"
	TicketHasFilterComments          TicketHasFilter = "comments"
)

var AllTicketHasFilter = []TicketHasFilter{
	TicketHasFilterTitle,
	TicketHasFilterProject,
	TicketHasFilterDescription,
	TicketHasFilterImprovement,
	TicketHasFilterTicketType,
	TicketHasFilterFlavor,
	TicketHasFilterPriority,
	TicketHasFilterStatus,
	TicketHasFilterOccurrenceModule,
	TicketHasFilterOccurrenceElement,
	TicketHasFilterDevice,
	TicketHasFilterDeviceModel,
	TicketHasFilterCreatedBy,
	TicketHasFilterAssignedTo,
	TicketHasFilterComments,
}

func (e TicketHasFilter) IsValid() bool {
	switch e {
	case TicketHasFilterTitle, TicketHasFilterProject, TicketHasFilterDescription, TicketHasFilterImprovement, TicketHasFilterTicketType, TicketHasFilterFlavor, TicketHasFilterPriority, TicketHasFilterStatus, TicketHasFilterOccurrenceModule, TicketHasFilterOccurrenceElement, TicketHasFilterDevice, TicketHasFilterDeviceModel, TicketHasFilterCreatedBy, TicketHasFilterAssignedTo, TicketHasFilterComments:
		return true
	}
	return false
}

func (e TicketHasFilter) String() string {
	return string(e)
}

func (e *TicketHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TicketHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TicketHasFilter", str)
	}
	return nil
}

func (e TicketHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TicketOrderable string

const (
	TicketOrderableTitle             TicketOrderable = "title"
	TicketOrderableProject           TicketOrderable = "project"
	TicketOrderableDescription       TicketOrderable = "description"
	TicketOrderableImprovement       TicketOrderable = "improvement"
	TicketOrderableOccurrenceModule  TicketOrderable = "occurrence_module"
	TicketOrderableOccurrenceElement TicketOrderable = "occurrence_element"
	TicketOrderableDevice            TicketOrderable = "device"
	TicketOrderableDeviceModel       TicketOrderable = "device_model"
	TicketOrderableCreatedBy         TicketOrderable = "created_by"
	TicketOrderableAssignedTo        TicketOrderable = "assigned_to"
)

var AllTicketOrderable = []TicketOrderable{
	TicketOrderableTitle,
	TicketOrderableProject,
	TicketOrderableDescription,
	TicketOrderableImprovement,
	TicketOrderableOccurrenceModule,
	TicketOrderableOccurrenceElement,
	TicketOrderableDevice,
	TicketOrderableDeviceModel,
	TicketOrderableCreatedBy,
	TicketOrderableAssignedTo,
}

func (e TicketOrderable) IsValid() bool {
	switch e {
	case TicketOrderableTitle, TicketOrderableProject, TicketOrderableDescription, TicketOrderableImprovement, TicketOrderableOccurrenceModule, TicketOrderableOccurrenceElement, TicketOrderableDevice, TicketOrderableDeviceModel, TicketOrderableCreatedBy, TicketOrderableAssignedTo:
		return true
	}
	return false
}

func (e TicketOrderable) String() string {
	return string(e)
}

func (e *TicketOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TicketOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TicketOrderable", str)
	}
	return nil
}

func (e TicketOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TicketPriority string

const (
	TicketPriorityHighest TicketPriority = "highest"
	TicketPriorityHigh    TicketPriority = "high"
	TicketPriorityMedium  TicketPriority = "medium"
	TicketPriorityLow     TicketPriority = "low"
	TicketPriorityLowest  TicketPriority = "lowest"
)

var AllTicketPriority = []TicketPriority{
	TicketPriorityHighest,
	TicketPriorityHigh,
	TicketPriorityMedium,
	TicketPriorityLow,
	TicketPriorityLowest,
}

func (e TicketPriority) IsValid() bool {
	switch e {
	case TicketPriorityHighest, TicketPriorityHigh, TicketPriorityMedium, TicketPriorityLow, TicketPriorityLowest:
		return true
	}
	return false
}

func (e TicketPriority) String() string {
	return string(e)
}

func (e *TicketPriority) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TicketPriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TicketPriority", str)
	}
	return nil
}

func (e TicketPriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TicketStatus string

const (
	TicketStatusCreated    TicketStatus = "created"
	TicketStatusWillDo     TicketStatus = "willDo"
	TicketStatusNotDoing   TicketStatus = "notDoing"
	TicketStatusInProgress TicketStatus = "inProgress"
	TicketStatusNextTime   TicketStatus = "nextTime"
	TicketStatusDone       TicketStatus = "done"
)

var AllTicketStatus = []TicketStatus{
	TicketStatusCreated,
	TicketStatusWillDo,
	TicketStatusNotDoing,
	TicketStatusInProgress,
	TicketStatusNextTime,
	TicketStatusDone,
}

func (e TicketStatus) IsValid() bool {
	switch e {
	case TicketStatusCreated, TicketStatusWillDo, TicketStatusNotDoing, TicketStatusInProgress, TicketStatusNextTime, TicketStatusDone:
		return true
	}
	return false
}

func (e TicketStatus) String() string {
	return string(e)
}

func (e *TicketStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TicketStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TicketStatus", str)
	}
	return nil
}

func (e TicketStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TicketType string

const (
	TicketTypeBug         TicketType = "bug"
	TicketTypeImprovement TicketType = "improvement"
)

var AllTicketType = []TicketType{
	TicketTypeBug,
	TicketTypeImprovement,
}

func (e TicketType) IsValid() bool {
	switch e {
	case TicketTypeBug, TicketTypeImprovement:
		return true
	}
	return false
}

func (e TicketType) String() string {
	return string(e)
}

func (e *TicketType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TicketType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TicketType", str)
	}
	return nil
}

func (e TicketType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserHasFilter string

const (
	UserHasFilterUsername   UserHasFilter = "username"
	UserHasFilterPhone      UserHasFilter = "phone"
	UserHasFilterRoles      UserHasFilter = "roles"
	UserHasFilterPassword   UserHasFilter = "password"
	UserHasFilterSkills     UserHasFilter = "skills"
	UserHasFilterExperience UserHasFilter = "experience"
	UserHasFilterPosition   UserHasFilter = "position"
	UserHasFilterTeamType   UserHasFilter = "team_type"
)

var AllUserHasFilter = []UserHasFilter{
	UserHasFilterUsername,
	UserHasFilterPhone,
	UserHasFilterRoles,
	UserHasFilterPassword,
	UserHasFilterSkills,
	UserHasFilterExperience,
	UserHasFilterPosition,
	UserHasFilterTeamType,
}

func (e UserHasFilter) IsValid() bool {
	switch e {
	case UserHasFilterUsername, UserHasFilterPhone, UserHasFilterRoles, UserHasFilterPassword, UserHasFilterSkills, UserHasFilterExperience, UserHasFilterPosition, UserHasFilterTeamType:
		return true
	}
	return false
}

func (e UserHasFilter) String() string {
	return string(e)
}

func (e *UserHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHasFilter", str)
	}
	return nil
}

func (e UserHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableUsername   UserOrderable = "username"
	UserOrderablePhone      UserOrderable = "phone"
	UserOrderablePassword   UserOrderable = "password"
	UserOrderableSkills     UserOrderable = "skills"
	UserOrderableExperience UserOrderable = "experience"
	UserOrderablePosition   UserOrderable = "position"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableUsername,
	UserOrderablePhone,
	UserOrderablePassword,
	UserOrderableSkills,
	UserOrderableExperience,
	UserOrderablePosition,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableUsername, UserOrderablePhone, UserOrderablePassword, UserOrderableSkills, UserOrderableExperience, UserOrderablePosition:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleAdmin UserRole = "admin"
	UserRoleUser  UserRole = "user"
)

var AllUserRole = []UserRole{
	UserRoleAdmin,
	UserRoleUser,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAdmin, UserRoleUser:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
